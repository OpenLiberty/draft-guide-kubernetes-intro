// INSTRUCTION: Please remove all comments that start INSTRUCTION prior to commit. Most comments should be removed, although not the copyright.
// INSTRUCTION: The copyright statement must appear at the top of the file
//
// Copyright (c) 2018 IBM Corporation and others.
// Licensed under Creative Commons Attribution-NoDerivatives
// 4.0 International (CC BY-ND 4.0)
//   https://creativecommons.org/licenses/by-nd/4.0/
//
// Contributors:
//     IBM Corporation
//
:projectid: kubernetes
:page-layout: guide
:page-duration: 40 minutes
:page-releasedate: 2018-05-30
:page-description: Explore how to deploy microservices to Kubernetes and manage your cluster.
:page-tags: ['microservices', 'Helm', 'Kubernetes', 'Docker', 'containers', 'kubectl', 'Minikube']
:page-permalink: /guides/{projectid}
:page-related-guides: ['docker', 'istio']
:common-includes: https://raw.githubusercontent.com/OpenLiberty/guides-common/master
:source-highlighter: prettify
= Deploying microservices to Kubernetes

[.hidden]
NOTE: This repository contains the guide documentation source. To view the guide in published form, view it on the https://openliberty.io/guides/{projectid}.html[Open Liberty website].

Explore how to deploy microservices in Open Liberty Docker containers to Kubernetes and manage them with the kubectl Kubernetes CLI.

:minikube-ip: 192.168.99.100
:kube: Kubernetes
:hashtag: #


// =================================================================================================
// What is {kube}
// =================================================================================================

== What is {kube}?

{kube} is an open source container orchestrator that automates many tasks involved in deploying,
managing, and scaling containerized applications.

Over the years, {kube} has become a major tool in containerized environments as containers are being
more and more utilized for all steps of a continuous delivery pipeline.

=== Why use {kube}?

Managing containers on their own can be challenging. While a few containers used for development by
a small team might not pose a problem, a large number of containers, all running various applications,
all sharing databases, all communicating with each other, and all needing to be run and monitored
every day of the week will give even a large team of experienced developers a headache. {kube} is a
developer's primary tool in containerized
environments. It handles scheduling, deployment, as well as mass deletion and creation of containers.
It provides update rollout capabilities on a large scale that would otherwise prove extremely tedious
to do. Imagine that you updated a Docker image, which now needs to propagate to a dozen containers.
While you could destroy and then recreate these containers, you could also issue a short one-line
command and have {kube} do all that updating for you. Of course this is just a simple example, the 
iceberg that is {kube} has a lot more to offer.

// {kube} provides much other functionality
// that simply makes your development, testing, and production environments much more stable, much more
// automated, and much more powerful to use. Some of this functionality, we're hoping you can learn in
// this guide.

=== Architecture

Deploying an application to Kubernetes simply means deploying an application to a Kubernetes cluster.

A typical {kube} cluster is a collection of physical or virtual machines called `nodes` that run
containerized applications. A cluster is made up of one master `node` that manages the cluster, and
multiple worker `nodes` that run the actual application instances inside {kube} objects called `Pods`.

A `Pod` is a basic building block in a {kube} cluster. It represents a single running process that
encapsulates a container or in some scenarios multiple closely coupled containers. `Pods` can be
replicated to scale applications and handle more traffic. From the perspective of a cluster, a set
of replicated `Pods` is still one application instance, although it might be made up of dozens of
instances of itself. A single `Pod` or a group of replicated `Pods` are managed by {kube} objects
called `Controllers`. A `Controller` handles replication, self-healing, rollout of updates, and general
management of `Pods`. Some examples of `Controllers` include `Deployments`, `StatefulSets`, and `DaemonSets`.
In this guide, you will work with `Deployments`.

A `Pod` or a group of replicated `Pods` are abstracted through {kube} objects called `Services`
that define a set of rules by which the `Pods` can be accessed. In a basic scenario, a {kube}
`Service` will expose a node port that can be used together with the cluster IP address to access
the `Pods` encapsulated by the `Service`. In this guide, however, you will set up an `Ingress`, which
is a {kube} object that contains a set of rules for mapping external requests to the `Services` inside 
a cluster, over protocols such as HTTP, as well as provides load-balancing and other functionality. An `Ingress` requires an Ingress Controller to process requests accordingly.

To learn about the various Kubernetes resources that you can configure, see the https://kubernetes.io/docs/concepts/.


// =================================================================================================
// Introduction
// =================================================================================================

== What you'll learn

You will learn how to deploy two microservices in Open Liberty Docker containers to a local {kube} cluster using the Kubernetes package
manager called Helm. Helm allows you to install packages or charts, which are sets of preconfigured
{kube} resources. Installing charts is much more convenient than creating and configuring Kubernetes
resources yourself. You will then manage your deployed microservices using the `kubectl` command line
interface for {kube}. The `kubectl` CLI is your primary tool for communicating with and managing your
{kube} cluster.

The two microservices you will deploy are called `name` and `ping`. The `name` microservice simply 
displays a brief greeting and the name of the
container that it runs in, making it easy to distinguish it from its other replicas. The `ping` microservice
simply pings the {kube} Service that encapsulates the Pods running the `name` microservice, demonstrating
how communication can be established between Pods inside a cluster.

You will use a local single-node {kube} cluster and employ NGINX as your Ingress controller.


// =================================================================================================
// Prerequisites
// =================================================================================================

== Prerequisites

Before you begin, make sure to have the following tools installed:

 - A containerization software for building containers. {kube} supports a variety
of container types and while you're not limited to any of them in particular, you should use `Docker`
as it's what this guide will focus on. For installation instructions, see https://docs.docker.com/install/.
- `kubernetes` - the {kube} orchestration platform. If you have a Docker installation that provides the {kube} environment then just use this. For example, in https://www.docker.com/products/docker-desktop[Docker Desktop] a local {kube} environment is pre-installed and enabled through https://docs.docker.com/docker-for-windows/kubernetes/[Docker for Windows settings] or https://docs.docker.com/docker-for-mac/kubernetes/[Docker for Mac Settings]. Otherwise you can use `Minikube` as a single-node {kube} cluster that runs locally in a virtual machine. For Minikube installation instructions see https://github.com/kubernetes/minikube. Make sure to read the "Requirements" section as different operating systems require different prerequisites to get Minikube running. 
- `kubectl` - a command line client interface for {kube}. If you have a Docker installation that provides kubectl, such as https://docs.docker.com/docker-for-windows/[Docker for Windows] then just use this. Otherwise install the client as described at https://kubernetes.io/docs/tasks/tools/install-kubectl/
- `helm` - a package manager for {kube}. For installation instructions see
https://docs.helm.sh/using_helm/{hashtag}installing-helm


There are two potential sets of instructions that you can follow depending on whether you are using Docker Desktop or Minikube for you {kube} cluster. Docker Desktop is a convenient way of running both Docker and Kubernetes on your machine, it is available on Windows and Mac. Minikube runs a {kube} cluster inside of a virtual machine, the default hypervisor is Virtual Box but it can be configured based on your preferences. You should only choose one of options A or B to proceed with this guide.

// =================================================================================================
// Getting Started
// =================================================================================================

include::{common-includes}/gitclone.adoc[]

// no "try what you'll build" section in this guide since it would be too long due to all setup the user will have to do.

:show-minikube:
== Option A: Minikube
include::_readme/main.adoc[]

:show-minikube!:
== Option B: Docker for Windows/Mac
include::_readme/main.adoc[]

// =================================================================================================
// finish
// =================================================================================================

== Great work! You're done!

You have just deployed two microservices to {kube} using Helm charts. You then scaled a microservice,
rolled out deployment updates, ran integration tests against miroservices that are running in a {kube}
cluster, and learned how to edit {kube} resources.

// Include the below from the guides-common repo to tell users how they can contribute to the guide
include::{common-includes}/finish.adoc[]

// DO NO CREATE ANYMORE SECTIONS AT THIS POINT
// Related guides will be added in automatically here if you included them in ":page-related-guides"
